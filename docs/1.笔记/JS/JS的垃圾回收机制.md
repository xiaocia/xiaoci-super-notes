# JS 的垃圾回收机制

众所周知,js 的数据分为基本类型和引用类型.

基本类型保存在栈内存,引用类型保存在堆内存.

不同的内存有不同的回收机制

## 栈内存的数据回收

```js
function foo() {
  var a = 1
  var b = { name: 'xiaoci1' }
  function showName() {
    var c = 1
    var d = { name: 'xiaoci2' }
  }
  showName()
}
foo()
```

![iShot_2024-08-07_15.40.39](/img/note_js_img/iShot_2024-08-07_15.40.39.png)

栈空间用来存放执行上下文,全局定义的基本变量在栈底的全局执行上下文中,不会出栈.在页面关闭时才会弹出销毁.

而函数执行上下文会在执行代码的过程中，如果遇到函数的主动调用，就会生成一个函数执行上下文，**入栈**到函数调用栈中；当函数调动完成之后，就会执行出栈操作.

在函数执行栈的过程中,会有一个记录当前执行状态的指针（称为 ESP）,指向调用栈中 **当前** 函数的执行上下文，表示当前正在执行当前函数.

在当前函数执行完之后,函数执行流程就进入了下一个函数的执行,同时 ESP 下移,当前的函数执行上下文失效.当有新的函数被调用时,创建新的函数执行上下文,入栈,覆盖掉失效的.

**_JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文_**

## 堆内存的数据回收

ESP下移后,栈内存被回收,但是堆内存的两个对象仍然占用着内存空间.

堆内存的回收最常见的**标记清除**和**引用计数**

### 引用计数

是一种 把对象是否不再需要定义为有没有别的对象引用它(对象包含函数的arguments,普通对象 等),如果没有引用指向该对象,该对象将被垃圾回收机制回收.

因为此方法在循环引用是比如

```js
const a = { name: 'a' }
const b = { name: 'b' }
a.bro = b
b.bro = a
```

以上a和b的相互引用,导致了他们的引用计数至少为1,始终不会被回收,造成内存泄露.

### 标记清除(主要)

标记过程:  首先会将内存中的所有变量都加上一个标记,假设所有对象都是垃圾,全是0. 然后从一个根元素(比如是window)出发,递归遍历根元素.在遍历的过程中,能到达的是活动元素标记是1,否则是垃圾数据.全被回收!!

比如上面的执行栈,当showName函数执行完,他的执行上下文被回收后,此时只有foo函数上下文.

此时开始了一轮回收,堆内存的1030和1050都被标记被0,先从全局开始遍历,然后遍历foo函数的执行上下文,发现了1050,将1050地址对应的对象标记为1.完成后,引擎发现竟然有一个标记是0的,也就是垃圾,就被回收了,释放内存空间.、

#### 优点: 实现简单

#### **缺点**: 

在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 **内存碎片**,并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题

![iShot_2024-08-07_16.22.28](/img/note_js_img/iShot_2024-08-07_16.22.28.png)

假设我们新建对象分配内存时需要大小为 `size`，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次遍历找出大于等于 `size` 的块才能给他

![iShot_2024-08-07_16.24.28](/img/note_js_img/iShot_2024-08-07_16.24.28.png)

怎么找到合适的内存块呢?

1. First-fit: 找到能放下的内存马上返回
2. Best-fit: 遍历全部,找到能放下的最小的块
3. Worst-fit: 找到最大的,并切下最size,给他

两个缺点: 

	 1. 空闲内存不连续,容易出现空闲内存块,还可能会出现分配所需内存过大的对象时找不到合适的块
	 1. 分配速度慢

#### 改进: **标记整理**算法

前面和标记一样,但是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存

![iShot_2024-08-07_16.24.28](/img/note_js_img/iShot_2024-08-07_16.35.06.png)

