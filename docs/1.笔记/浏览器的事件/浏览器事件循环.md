## 浏览器

### 浏览器进程模型

1. 浏览器是多进程多线程的，会先开启浏览器进程，随后浏览器进程会开启子线程

2. 主要进程有浏览器进程、网络进程、渲染进程。

   1. 浏览器进程主要负责界面显示（标签页、地址栏、刷新图标、书签等）、用户交互、子进程管理等。浏览器进程会启动多个线程处理不同的任务

   2. 网络进程负责加载网络资源，也会启动多个线程处理不同的任务。

   3. 渲染进程开启后，启动一个主线程，负责执行js、HTML、css代码；默认情况下，浏览器会为每个标签开启一个线程，来保证不同的标签之间不会影响（未来可能会改）。

3. 渲染主线程的任务包括但是不限于：
   - 解析HTML
   - 解析CSS
   - 计算样式
   - 布局
   - 处理图层
   - 每秒刷新页面60次
   - 执行全局JS代码
   - 执行事件处理函数
   - 计时器的回调函数
   - ...

为什么渲染主进程不用多个进程处理？

### 渲染主线程如何工作

1.  开始时，渲染主线程会开启一个无限循环
2. 每一次循环会检测任务队列是否有任务。如果有，就取出第一个执行，执行完进入下一个循环；如果没有，则进入休眠
3. 其余的所有线程（包括其他进程的线程）可以随时向任务队列中添加任务。新任务会被添加到任务队列的队尾。在添加新任务时，如果是休眠状态，会唤醒主线程以循环拿取任务

**整个过程，被称为事件循环**

### 如何理解JS的异步？

​	JS是一门单线程的语言，这是因为JS是运行在浏览器的渲染主线程上的，渲染主线程只有一个。渲染主线程承载着很多工作，渲染页面、JS执行、都在其中运行。

​	如果使用同步的方式，极有可能会阻塞渲染主线程，从而导致任务队列的其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白消耗时间，一方面会导致页面无法更新，造成卡死的现象。

​	所以浏览器采用异步的方式来避免。当某些任务发生时，比如计时器、网络请求、事件监听，主线程将其任务交给其他线程来处理，自己立刻结束任务的执行，开始执行下一个任务。当其他线程完成时，会将时先传递的回调函数包装成任务放到任务队列的末尾排队，等待主线程的执行。

​	在这种异步模式下，主线程永不阻塞，最大限度的保证单线程的流畅。

### 任务有优先级吗？

1. 任务没有优先级，在任务队列中先进先出；但是***任务队列有优先级***。
2.  **每个任务都有一个任务类型，同一个类型的任务必须在同一个队列执行，不同类型的任务可以分属不同的队列（可以多个类型任务在一个队列）。在一次事件循环中，浏览器可以根据实际情况从不同的任务队列中取任务执行。**
3. **浏览器必须准备好一个微队列，微队列中的任务优先其他所有任务队列执行。**
4. Chrome目前至少有三种任务队列：
   1. 延时队列： 用于存放计时器的回调函数，优先级**中**。
   2. 交互队列： 用于存放用户操作后产生的事件处理任务，优先级**高**。
   3. 微队列： 存放需要最先执行的任务，优先级**最高**。

***单线程是异步产生的原因***

***事件循环是异步的实现方式***

### 事件循环：

​	事件循环是浏览器渲染主线程的工作方式。

​	在Chrome中，开启一个永远不会结束的for循环，每次循环从任务队列中取出第一个任务执行，而其他的线程只需要在合适的时机把任务加到任务队列的末尾。

​	过去把任务队分为宏任务和微任务，但是随着浏览器的发展，这样处理方式已不能满足，取代的是一种更加灵活的处理方式。

​	根据W3C的规定，每个任务有不同的类型的，同一种类型必须都在同一个队列，不同类型可以在不同的队列（不同类型可以在一个队列）。不同的任务队列有不同的优先级，在每一次的事件循环，浏览器可以根据实际情况决定从哪个任务队列取出任务。但是浏览器必须有一个微队列，微队列的任务有最高的优先级，必须优先执行。

### JS中计时器是否精准？

不行 因为：

1. 计算机硬件没有原子钟，不能精确计时
2. JS的计时器最终调用的是操作系统的函数，操作系统的计时函数本身就存在误差。
3. 按照W3C的标准，计时器嵌套超过5层，会至少携带4毫秒的误差
4. 受事件循环的影响，计时器的回调函数只能在渲染主线程空闲的时间运行，又带来了偏差。